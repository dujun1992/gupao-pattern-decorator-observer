【创建型】
工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、建造者模式（Builder）、原型模（Prototype）、单例模式(Singleton)
【结构型】
适配器模式(Adapter)、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）、门面模式（Facade）、享元模式（Flyweight）、代理模式（Proxy）
【行为型】
解释器模式（Interpreter）、模板方法模式（Template Method）、责任链模式（Chain of Responsibility）、命令模式（Command）、迭代器模式（Iterator）、调解者模式（Mediator）、备忘录模式（Memento）、观察者模式（Observer）、状态模式（State）、策略模式（Strategy）、访问者模式（Visitor）

-------------------------------------------------------------------------------------------------------------------------------------------------
单例模式：独一无二，只会出现一个
工厂模式：封装创建过程，输出对象
原型模式：批量克隆对象
适配器模式：接口转化，使不兼容的对象能一起工作
委派模式：分配，转发，控制
策略模式：用户选择，结果统一
装饰者模式：包装，同宗同源，is-a
代理模式：保护目标对象，增强调用功能
模版模式：流程标准化，自己实现定制
观察者模式：事件触发和回调，响应事件，发布订阅
-----------------------------------------------------------------------------------------------------------------------------------------------------
OOP : ObjectOrientedProgramming（面向对象编程）用程序归纳总结生活中一切事物。封装、继承、多态。
BOP : BeanOriented Programming（面向 Bean编程）面向 Bean（普通的 Java类）设计程序，解放程序员。一切从Bean开始。
AOP : Aspect Oriented Programming(面向切面编程)找出多个类中有一定规律的代码，开发时拆开，运行时再合并。面向切面编程，即面向规则编程。解耦，专人做专事。
IOC : Inversion of Control（控制反转）将 new 对象的动作交给 Spring 管理，并由Spring保存已创建的对象（IOC 容器）。转交控制权（即控制权反转）
DI/DL :  Dependency Injection（依赖注入）或者Dependency Lookup（依赖查找）依赖注入、依赖查找，Spring不仅保存自己创建的对象，而且保存对象与对象之间的关系。注入即赋值，主要三种方式构造方法、 set方法、直接赋值。
-----------------------------------------------------------------------------------------------
【单例模式和工厂模式】
实际业务代码中，通常会把工厂类设计为单例。 
【策略模式和工厂模式】
1、工厂模式包含工厂方法模式和抽象工厂模式是创建型模式，策略模式属于行为型模式。
2、工厂模式主要目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不同的行为。 
【策略模式和委派模式】
1、策略模式是委派模式内部的一种实现形式，策略模式关注的结果是否能相互替代。如支付方式：AliPay,WechatPay...
2、委派模式更关注分发和调度的过程。 有可能采用if...else...条件分支语句来分发，内部也使用策略模式。
【模板方法模式和工厂方法模式】
工厂方法是模板方法的一种特殊实现。
对于工厂方法模式的create()方法而言，相当于只有一个步骤的模板方法模式。这一个步骤交给子类去实现。而模板方法呢，将needHomework()方法和checkHomework()方法交给子类实现，needHomework()方法和 checkHomework()方法又属于父类的某一个步骤且不可变更。 
【模板方法模式和策略模式】
1、模板方法和策略模式都有封装算法。
2、策略模式是使不同算法可以相互替换，且不影响客户端应用层的使用。
3、模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现。策略模式算法实现是封闭的。
4、模板方法模式不能改变算法流程，策略模式可以改变算法流程且可替换。策略模式通常用来代替if...else...等条件分支语句。
【装饰者模式和静态代理模式】
1、装饰者模式关注点在于给对象动态添加方法（扩展或者覆盖），而代理更加注重控制对对象的访问，对目标方法的增强。
2、代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把被装饰者作为构造参数。
装饰者和代理者虽然都持有对方引用，但逻辑处理重心是不一样的。
【装饰者模式和适配器模式】
1、装饰者模式和适配器模式都是属于包装器模式（Wrapper Pattern）。
2、装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类（is-a），而适配器和被适配者可以实现不同的接口（has-a），目的为了兼容。
【适配器模式和静态代理模式】
适配器可以结合静态代理来实现，保存被适配对象的引用，但不是唯一的实现方式，还有继承。 
【适配器模式和策略模式】
在适配业务复杂的情况下，如选择根据不同情况，选择某个适配器时，可利用策略模式优化动态适配逻辑。
